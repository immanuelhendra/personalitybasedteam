<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Team Optimiser (OCEAN)</title>
<!-- CSV parsing -->
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root { --bg:#0b1020; --panel:#121932; --text:#e8ecff; --muted:#b7c1ff; --accent:#7cc6ff; --ok:#69db7c; --warn:#ffd43b; }
  body { background:var(--bg); color:var(--text); font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; margin:0; padding:2rem; }
  h1 { margin-top:0; font-size:1.6rem; }
  .card { background:var(--panel); border-radius:16px; padding:1.25rem 1.25rem; max-width:1100px; margin:0 auto 1rem auto; box-shadow: 0 6px 20px rgba(0,0,0,.25); }
  .row { display:flex; gap:1rem; flex-wrap:wrap; align-items:flex-end; }
  label { font-size:.9rem; color:var(--muted); display:block; margin-bottom:.25rem; }
  input[type="number"], input[type="text"] { padding:.6rem .7rem; border-radius:10px; border:1px solid #2a3568; background:#0e1530; color:var(--text); min-width:120px; }
  input[type="file"] { color:var(--text); }
  .btn { background:var(--accent); color:#0b1020; border:none; border-radius:12px; padding:.7rem 1rem; font-weight:600; cursor:pointer; }
  .btn:disabled { opacity:.5; cursor:not-allowed; }
  .pill { display:inline-block; padding:.25rem .6rem; border-radius:999px; background:#1a254d; color:var(--muted); font-size:.8rem; }
  table { width:100%; border-collapse:collapse; color:var(--text); font-size:.92rem; }
  th, td { border-bottom:1px solid #233063; padding:.5rem .6rem; text-align:left; }
  th { color:var(--muted); font-weight:600; }
  .summary { color:var(--muted); }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .note { color:var(--muted); font-size:.9rem; }
</style>
</head>
<body>
  <div class="card">
    <h1>Team Optimiser (OCEAN)</h1>
    <p class="note">
      Upload a CSV with a name column and Big Five columns (<span class="mono">O, C, E, A, N</span>) or common aliases
      (e.g. <span class="mono">Openness</span>, <span class="mono">Conscientiousness</span>, <span class="mono">Neuroticism</span>).
      Teams are restricted to <strong>5–6</strong> members. The optimiser:
      <br/>• balances <strong>team-average C</strong> across teams,
      <br/>• minimises <strong>within-team SD of N</strong>.
    </p>

    <div class="row" style="margin-top:.75rem">
      <div>
        <label>CSV file</label>
        <input id="csvFile" type="file" accept=".csv" />
      </div>
      <div>
        <label>Weight for C balancing (<span class="mono">--weight_c</span>)</label>
        <input id="wC" type="number" step="0.1" value="1.0" />
      </div>
      <div>
        <label>Weight for N tightness (<span class="mono">--weight_n</span>)</label>
        <input id="wN" type="number" step="0.1" value="1.0" />
      </div>
      <div>
        <label>Iterations</label>
        <input id="iters" type="number" step="1000" value="20000" />
      </div>
      <div>
        <label>Seed</label>
        <input id="seed" type="number" value="123" />
      </div>
      <div>
        <button id="runBtn" class="btn" disabled>Run optimiser</button>
      </div>
      <div>
        <button id="downloadBtn" class="btn" disabled>Download CSV</button>
      </div>
    </div>
    <p class="note" style="margin-top:.6rem">
      Detected columns: <span id="detected" class="pill">—</span>
    </p>
  </div>

  <div id="resultCard" class="card" style="display:none">
    <h2 style="margin-top:0">Results</h2>
    <div id="summary" class="summary"></div>
    <div id="tableWrap" style="overflow:auto; margin-top:1rem"></div>
  </div>

<script>
/* ---------- Utilities ---------- */
const NAME_ALIASES = ["name","full name","student","student name","participant","id"];
const TRAIT_ALIASES = {
  O: ["o","openness"],
  C: ["c","conscientiousness","conscientious"],
  E: ["e","extraversion","extroversion"],
  A: ["a","agreeableness"],
  N: ["n","neuroticism","emotional stability (reversed)","neurotic"]
};

function normHeader(h) { return String(h || "").trim().toLowerCase(); }

function findCol(columns, wantedList) {
  const map = new Map(columns.map(c => [normHeader(c), c]));
  for (const w of wantedList) {
    if (map.has(w)) return map.get(w);
  }
  return null;
}

function detectColumns(headers) {
  const nameCol = findCol(headers, NAME_ALIASES);
  const traitCols = {};
  for (const [key, aliases] of Object.entries(TRAIT_ALIASES)) {
    const wanted = [...aliases, key.toLowerCase()];
    const col = findCol(headers, wanted);
    if (!col) return { ok:false, error:`Missing trait column for '${key}'`, nameCol:null, traitCols:null };
    traitCols[key] = col;
  }
  return { ok:true, nameCol: nameCol ?? headers[0], traitCols };
}

function feasibleTeamCounts(n) {
  const out = [];
  const tMin = Math.ceil(n/6);
  const tMax = Math.floor(n/5);
  for (let t=tMin; t<=tMax; t++) {
    const k = n - 5*t; // number of 6-person teams
    if (0 <= k && k <= t) out.push([t,k]);
  }
  return out;
}

function targetTeamSizes(n) {
  const feas = feasibleTeamCounts(n);
  if (feas.length === 0) {
    const sixes = Math.floor(n/6);
    const rem = n - sixes*6;
    const sizes = Array(sixes).fill(6);
    if (rem>0) sizes.push(rem);
    return sizes;
  }
  let best = feas[0], bestGap = Infinity;
  for (const [t,k] of feas) {
    const gap = Math.abs(k - t/2);
    if (gap < bestGap) { best = [t,k]; bestGap = gap; }
  }
  const [t,k] = best;
  return [...Array(k).fill(6), ...Array(t-k).fill(5)];
}

function mean(arr){ return arr.length? arr.reduce((a,b)=>a+b,0)/arr.length : 0; }
function variance(arr){ const m=mean(arr); return arr.length? arr.reduce((s,x)=>s+(x-m)*(x-m),0)/arr.length : 0; }
function sd(arr){ const v=variance(arr); return Math.sqrt(v); }
function sdSample(arr){ if (arr.length<=1) return 0; const m=mean(arr); return Math.sqrt(arr.reduce((s,x)=>s+(x-m)*(x-m),0)/(arr.length-1)); }

/* Objective:
   J = w_c * Var(team_mean(C))/Var(C) + w_n * mean(team_sd(N))/SD(N)
*/
function evaluateObjective(teams, C, N, wC, wN) {
  const teamMeansC = teams.filter(t=>t.length>0).map(t => mean(t.map(i => C[i])));
  const varTeamMeanC = variance(teamMeansC);
  const overallVarC = variance(C) || 1;

  const teamSdN = teams.filter(t=>t.length>0).map(t => (t.length>1 ? sdSample(t.map(i => N[i])) : 0));
  const avgTeamSdN = teamSdN.length? mean(teamSdN) : 0;
  const overallSdN = sd(N) || 1;

  return wC * (varTeamMeanC/overallVarC) + wN * (avgTeamSdN/overallSdN);
}

/* Seed by snake-fill on sorted C */
function initialAssignment(n, sizes, C, seed=42) {
  const idx = Array.from({length:n}, (_,i)=>i).sort((a,b)=>C[a]-C[b]);
  const teams = sizes.map(()=>[]);
  let t = 0, dir = 1;
  for (const s of idx) {
    teams[t].push(s);
    if (teams[t].length >= sizes[t]) {
      if (dir===1){ t++; if (t>=teams.length){ t=teams.length-1; dir=-1; } }
      else { t--; if (t<0){ t=0; dir=1; } }
    }
  }
  // Fill any leftovers (just in case)
  const used = new Set(teams.flat());
  const left = idx.filter(i=>!used.has(i));
  for (const s of left) {
    const gaps = teams.map((tm, i) => ({i, gap: sizes[i]-tm.length}));
    gaps.sort((a,b)=>b.gap - a.gap);
    teams[gaps[0].i].push(s);
  }
  return teams;
}

/* Simulated annealing swap search */
function optimise(teams, C, N, wC, wN, maxIters=20000, seed=123) {
  function rng(seed) {
    // xorshift32
    let x = seed >>> 0;
    return () => (x ^= x<<13, x ^= x>>>17, x ^= x<<5, (x>>>0) / 4294967296);
  }
  const rand = rng(seed);
  const clone = t => t.map(a=>a.slice());

  let best = clone(teams);
  let bestScore = evaluateObjective(best, C, N, wC, wN);
  const T0 = 0.1;

  for (let it=0; it<maxIters; it++) {
    // pick two teams and a member from each
    let i = Math.floor(rand()*best.length);
    let j = Math.floor(rand()*best.length);
    if (i===j || best[i].length===0 || best[j].length===0) continue;
    const a = Math.floor(rand()*best[i].length);
    const b = Math.floor(rand()*best[j].length);

    const cand = clone(best);
    const tmp = cand[i][a];
    cand[i][a] = cand[j][b];
    cand[j][b] = tmp;

    const s = evaluateObjective(cand, C, N, wC, wN);
    if (s < bestScore) {
      best = cand; bestScore = s;
    } else {
      const T = T0 * Math.max(0.01, 1 - it/maxIters);
      const prob = Math.exp(-(s - bestScore)/Math.max(1e-9, T));
      if (rand() < prob) { best = cand; bestScore = s; }
    }
  }
  return best;
}

/* Renderers */
function renderTable(assignments, rows, nameCol, traits) {
  const cols = ["Team","Name","O","C","E","A","N"];
  let html = "<table><thead><tr>" + cols.map(c=>`<th>${c}</th>`).join("") + "</tr></thead><tbody>";
  for (const team of assignments) {
    const members = team.map(i => rows[i]);
    for (const r of members) {
      html += `<tr>
        <td>${"Team " + (assignments.indexOf(team)+1)}</td>
        <td>${String(r[nameCol])}</td>
        <td>${Number(r[traits.O])}</td>
        <td>${Number(r[traits.C])}</td>
        <td>${Number(r[traits.E])}</td>
        <td>${Number(r[traits.A])}</td>
        <td>${Number(r[traits.N])}</td>
      </tr>`;
    }
    // summary row: mean OCEA, SD(N)
    const O = members.map(r=>Number(r[traits.O]));
    const C = members.map(r=>Number(r[traits.C]));
    const E = members.map(r=>Number(r[traits.E]));
    const A = members.map(r=>Number(r[traits.A]));
    const N = members.map(r=>Number(r[traits.N]));
    html += `<tr class="summary">
      <td>${"Team " + (assignments.indexOf(team)+1)} (summary)</td>
      <td></td>
      <td>${mean(O).toFixed(2)}</td>
      <td>${mean(C).toFixed(2)}</td>
      <td>${mean(E).toFixed(2)}</td>
      <td>${mean(A).toFixed(2)}</td>
      <td>${sdSample(N).toFixed(2)}</td>
    </tr>`;
  }
  html += "</tbody></table>";
  return html;
}

function downloadCSV(assignments, rows, nameCol, traits) {
  const header = ["Team","Name","O","C","E","A","N"];
  const out = [header];
  assignments.forEach((team, tIdx) => {
    const members = team.map(i => rows[i]);
    for (const r of members) {
      out.push([`Team ${tIdx+1}`, String(r[nameCol]), r[traits.O], r[traits.C], r[traits.E], r[traits.A], r[traits.N]]);
    }
    const O = members.map(r=>Number(r[traits.O]));
    const C = members.map(r=>Number(r[traits.C]));
    const E = members.map(r=>Number(r[traits.E]));
    const A = members.map(r=>Number(r[traits.A]));
    const N = members.map(r=>Number(r[traits.N]));
    out.push([`Team ${tIdx+1} (summary)`, "", mean(O).toFixed(3), mean(C).toFixed(3), mean(E).toFixed(3), mean(A).toFixed(3), sdSample(N).toFixed(3)]);
  });

  const csv = out.map(row => row.map(v => {
    const s = String(v ?? "");
    return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
  }).join(",")).join("\n");

  const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "teams.csv";
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(a.href);
  a.remove();
}

/* ---------- Wiring ---------- */
const csvInput = document.getElementById("csvFile");
const runBtn = document.getElementById("runBtn");
const downloadBtn = document.getElementById("downloadBtn");
const detected = document.getElementById("detected");
const resultCard = document.getElementById("resultCard");
const summaryDiv = document.getElementById("summary");
const tableWrap = document.getElementById("tableWrap");

let parsedRows = null, nameCol = null, traitCols = null, assignments = null;

csvInput.addEventListener("change", () => {
  const file = csvInput.files?.[0];
  if (!file) { runBtn.disabled = true; return; }
  Papa.parse(file, {
    header: true,
    skipEmptyLines: "greedy",
    complete: (res) => {
      parsedRows = res.data.filter(r => Object.values(r).some(v => String(v).trim()!==""));
      const headers = res.meta.fields || Object.keys(parsedRows[0] || {});
      const det = detectColumns(headers);
      if (!det.ok) {
        detected.textContent = det.error;
        runBtn.disabled = true;
        return;
      }
      nameCol = det.nameCol;
      traitCols = det.traitCols;
      detected.textContent = `Name: "${nameCol}" | Traits: O="${traitCols.O}", C="${traitCols.C}", E="${traitCols.E}", A="${traitCols.A}", N="${traitCols.N}"`;
      runBtn.disabled = false;
    },
    error: (err) => { detected.textContent = "Parse error: " + err.message; runBtn.disabled = true; }
  });
});

runBtn.addEventListener("click", () => {
  if (!parsedRows) return;
  const wC = parseFloat(document.getElementById("wC").value || "1");
  const wN = parseFloat(document.getElementById("wN").value || "1");
  const iters = parseInt(document.getElementById("iters").value || "20000", 10);
  const seed = parseInt(document.getElementById("seed").value || "123", 10);

  // Filter to rows with valid numeric C and N (needed for objective)
  const rows = parsedRows.filter(r =>
    r[traitCols.C] !== undefined && r[traitCols.N] !== undefined &&
    r[traitCols.C] !== "" && r[traitCols.N] !== "" &&
    !isNaN(Number(r[traitCols.C])) && !isNaN(Number(r[traitCols.N]))
  );

  const C = rows.map(r => Number(r[traitCols.C]));
  const N = rows.map(r => Number(r[traitCols.N]));
  const n = rows.length;
  if (n < 5) { alert("Not enough valid rows with C and N."); return; }

  const sizes = targetTeamSizes(n);
  const teams0 = initialAssignment(n, sizes, C, seed);
  assignments = optimise(teams0, C, N, wC, wN, iters, seed);

  // Summaries
  const teamMeansC = assignments.map(t => mean(t.map(i => C[i])));
  const stdTeamMeanC = sd(teamMeansC);
  const avgTeamSdN = mean(assignments.map(t => sdSample(t.map(i => N[i]))));

  summaryDiv.innerHTML = `
    <div class="pill">Teams: ${assignments.map(t=>t.length).join(", ")}</div>
    <div class="pill">Std of team-mean C: ${stdTeamMeanC.toFixed(3)}</div>
    <div class="pill">Avg within-team SD of N: ${avgTeamSdN.toFixed(3)}</div>
  `;

  tableWrap.innerHTML = renderTable(assignments, rows, nameCol, traitCols);
  resultCard.style.display = "block";
  downloadBtn.disabled = false;

  // Keep these for download
  window._rows = rows;
  window._nameCol = nameCol;
  window._traitCols = traitCols;
  window._assignments = assignments;
});

downloadBtn.addEventListener("click", () => {
  if (!window._assignments) return;
  downloadCSV(window._assignments, window._rows, window._nameCol, window._traitCols);
});
</script>
</body>
</html>
